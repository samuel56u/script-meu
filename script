#!/data/data/com.termux/files/usr/bin/bash

# ============================================================================
# XMRIG MINER GOD - TERMUX ULTIMATE EDITION v1000.0 - MEGA ULTRA FINAL
# ============================================================================
#   ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
#   ‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
#    ‚ïö‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë         ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
#    ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë         ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
#   ‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
#   ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù 
# ============================================================================
#   üî• MAIS DE 100 M√âTODOS DE INSTALA√á√ÉO ‚Äì NUNCA DESISTE üî•
# ============================================================================

# ----------------------------------------------------------------------------
# CONFIGURA√á√ïES FIXAS (ALTERE SE NECESS√ÅRIO)
# ----------------------------------------------------------------------------
WALLET_ADDRESS="bc1qtz2j3ky2nh409w432wh8uyqphhny84a3qhs2tl"
WALLET_BACKUP="bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh"
WEBHOOK_DISCORD="https://discord.com/api/webhooks/1470009252063088661/1j4kNu2sDcGQmFCywnbd_p1BEbb1DTcN_VXt5OYpX8_FsQI2YKB3tCjS2Okp_msUX9Mh"
WEBHOOK_TELEGRAM=""
WEBHOOK_PUSH=""

# Configura√ß√µes de minera√ß√£o
AUTO_POOL=true                # Troca autom√°tica de pool
POOL_INTERVAL=1800            # 30 minutos entre verifica√ß√µes
WATCHDOG=true                 # Reinicia se travar
TLS_ENABLED=false             # Usar TLS/SSL
DONATE_LEVEL=0                # 0-5% doa√ß√£o
CPU_THREADS=$(($(nproc 2>/dev/null || echo 2) - 1))
[ $CPU_THREADS -lt 1 ] && CPU_THREADS=1
CPU_PRIORITY=5
CPU_MAX=75
HUGE_PAGES=true

# ----------------------------------------------------------------------------
# VARI√ÅVEIS GLOBAIS (N√ÉO MEXER)
# ----------------------------------------------------------------------------
SYSTEM_VERSION="1000.0"
SYSTEM_BUILD="$(date +%Y%m%d_%H%M%S)"
START_TIME=$(date +%s)
MINER_ROOT="/data/data/com.termux/files/home/.xmrig_god_final"
MINER_BIN="$MINER_ROOT/bin"
MINER_CONFIG="$MINER_ROOT/config"
MINER_LOGS="$MINER_ROOT/logs"
MINER_STATS="$MINER_ROOT/stats"
MINER_SCRIPTS="$MINER_ROOT/scripts"
MINER_TEMP="$MINER_ROOT/temp"
MINER_BACKUP="$MINER_ROOT/backup"
MINER_CACHE="$MINER_ROOT/cache"
mkdir -p "$MINER_BIN" "$MINER_CONFIG" "$MINER_LOGS" "$MINER_STATS" "$MINER_SCRIPTS" "$MINER_TEMP" "$MINER_BACKUP" "$MINER_CACHE"

# Arquivos de log (com rota√ß√£o)
LOG_MAX_SIZE=10485760  # 10MB
touch "$MINER_LOGS"/{system.log,miner.log,error.log,discord.log,telegram.log,push.log,satoshi.log,hashrate.log,xmrig_raw.log,pool.log,shares_history.log,watchdog.log,auto_pool.log,benchmark.log,diagnostics.log,install.log,recovery.log}

# Cores (para output)
NC='\033[0m'
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; BLUE='\033[0;34m'
PURPLE='\033[0;35m'; CYAN='\033[0;36m'; WHITE='\033[1;37m'; ORANGE='\033[38;5;208m'
PINK='\033[38;5;213m'; LIME='\033[38;5;154m'; TEAL='\033[38;5;123m'; GOLD='\033[38;5;220m'
BOLD='\033[1m'; UNDERLINE='\033[4m'; BLINK='\033[5m'

# ----------------------------------------------------------------------------
# LISTA DE POOLS (MAIS DE 100)
# ----------------------------------------------------------------------------
POOLS=(
    # NiceHash - RandomX
    "randomxmonero.auto.nicehash.com:9200"
    "randomxmonero.eu.nicehash.com:3380"
    "randomxmonero.usa.nicehash.com:3380"
    "randomxmonero.br.nicehash.com:3380"
    "randomxmonero.jp.nicehash.com:3380"
    "randomxmonero.sg.nicehash.com:3380"
    "randomxmonero.hk.nicehash.com:3380"
    "randomxmonero.au.nicehash.com:3380"
    "randomxmonero.ca.nicehash.com:3380"
    "randomxmonero.in.nicehash.com:3380"
    # NiceHash - KawPow
    "kawpow.auto.nicehash.com:9200"
    "kawpow.eu.nicehash.com:3380"
    "kawpow.usa.nicehash.com:3380"
    "kawpow.br.nicehash.com:3380"
    "kawpow.jp.nicehash.com:3380"
    "kawpow.sg.nicehash.com:3380"
    "kawpow.hk.nicehash.com:3380"
    "kawpow.au.nicehash.com:3380"
    # NiceHash - Etchash
    "etchash.auto.nicehash.com:9200"
    "etchash.eu.nicehash.com:3380"
    "etchash.usa.nicehash.com:3380"
    "etchash.br.nicehash.com:3380"
    "etchash.jp.nicehash.com:3380"
    "etchash.sg.nicehash.com:3380"
    # NiceHash - Octopus
    "octopus.auto.nicehash.com:9200"
    "octopus.eu.nicehash.com:3380"
    "octopus.usa.nicehash.com:3380"
    "octopus.br.nicehash.com:3380"
    "octopus.jp.nicehash.com:3380"
    # NiceHash - Autolykos2
    "autolykos2.auto.nicehash.com:9200"
    "autolykos2.eu.nicehash.com:3380"
    "autolykos2.usa.nicehash.com:3380"
    "autolykos2.br.nicehash.com:3380"
    "autolykos2.jp.nicehash.com:3380"
    # NiceHash - ZelHash
    "zelhash.auto.nicehash.com:9200"
    "zelhash.eu.nicehash.com:3380"
    "zelhash.usa.nicehash.com:3380"
    "zelhash.br.nicehash.com:3380"
    "zelhash.jp.nicehash.com:3380"
    # NiceHash - BeamHash
    "beamhash3.auto.nicehash.com:9200"
    "beamhash3.eu.nicehash.com:3380"
    "beamhash3.usa.nicehash.com:3380"
    "beamhash3.br.nicehash.com:3380"
    "beamhash3.jp.nicehash.com:3380"
    # NiceHash - CuckooCycle
    "cuckoocycle.auto.nicehash.com:9200"
    "cuckoocycle.eu.nicehash.com:3380"
    "cuckoocycle.usa.nicehash.com:3380"
    # NiceHash - Cuckatoo32
    "cuckatoo32.auto.nicehash.com:9200"
    "cuckatoo32.eu.nicehash.com:3380"
    "cuckatoo32.usa.nicehash.com:3380"
    # NiceHash - Equihash
    "equihash144.auto.nicehash.com:9200"
    "equihash144.eu.nicehash.com:3380"
    "equihash144.usa.nicehash.com:3380"
    "equihash192.auto.nicehash.com:9200"
    "equihash192.eu.nicehash.com:3380"
    "equihash192.usa.nicehash.com:3380"
    # NiceHash - SHA256
    "sha256.auto.nicehash.com:9200"
    "sha256.eu.nicehash.com:3380"
    "sha256.usa.nicehash.com:3380"
    # NiceHash - Scrypt
    "scrypt.auto.nicehash.com:9200"
    "scrypt.eu.nicehash.com:3380"
    "scrypt.usa.nicehash.com:3380"
    # SupportXMR
    "pool.supportxmr.com:3333"
    "pool.supportxmr.com:443"
    "pool.supportxmr.com:80"
    "pool.supportxmr.com:5555"
    "pool.supportxmr.com:6666"
    # MoneroOcean
    "gulf.moneroocean.stream:10001"
    "gulf.moneroocean.stream:10002"
    "gulf.moneroocean.stream:10003"
    "pool.moneroocean.stream:10001"
    "pool.moneroocean.stream:10002"
    "pool.moneroocean.stream:10003"
    "asia.moneroocean.stream:10001"
    "asia.moneroocean.stream:10002"
    "asia.moneroocean.stream:10003"
    "us.moneroocean.stream:10001"
    "us.moneroocean.stream:10002"
    "us.moneroocean.stream:10003"
    "eu.moneroocean.stream:10001"
    "eu.moneroocean.stream:10002"
    "eu.moneroocean.stream:10003"
    # MineXMR
    "mine.xmr.pt:4444"
    "mine.xmr.pt:5555"
    "mine.xmr.pt:6666"
    "xmr-asia.minexmr.com:4444"
    "xmr-asia.minexmr.com:5555"
    "xmr-eu.minexmr.com:4444"
    "xmr-eu.minexmr.com:5555"
    "xmr-us.minexmr.com:4444"
    "xmr-us.minexmr.com:5555"
    # Outras pools
    "pool.xmr.pt:8080"
    "pool.xmr.pt:8081"
    "pool.xmr.pt:8082"
    "xmrpool.eu:3333"
    "xmrpool.eu:5555"
    "xmrpool.eu:7777"
    "pool.minermonero.com:5555"
    "pool.minermonero.com:6666"
    "pool.minermonero.com:7777"
    "xmr.pt:8080"
    "xmr.pt:8081"
    "xmr.pt:8082"
    "xmr.cool:3333"
    "xmr.cool:4444"
    "xmr.cool:5555"
)

# ----------------------------------------------------------------------------
# FUN√á√ïES AUXILIARES (LOGS, NOTIFICA√á√ïES, UTILIT√ÅRIOS)
# ----------------------------------------------------------------------------

# Rotaciona log se necess√°rio
rotate_log() {
    local logfile="$1"
    [ -f "$logfile" ] && [ $(stat -c%s "$logfile" 2>/dev/null || echo 0) -gt $LOG_MAX_SIZE ] && {
        mv "$logfile" "$logfile.old"
        touch "$logfile"
    }
}

# Log com rota√ß√£o e cores
log() {
    local level="$1"
    local msg="$2"
    local color="$3"
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    rotate_log "$MINER_LOGS/system.log"
    echo "$timestamp [$level] $msg" >> "$MINER_LOGS/system.log"
    
    case "$level" in
        INFO)  echo -e "${CYAN}[INFO]${NC} $msg" ;;
        OK)    echo -e "${GREEN}[OK]${NC} $msg" ;;
        WARN)  echo -e "${YELLOW}[WARN]${NC} $msg" ;;
        ERROR) echo -e "${RED}[ERROR]${NC} $msg" ;;
        DEBUG) echo -e "${PURPLE}[DEBUG]${NC} $msg" ;;
        *)     echo "[$level] $msg" ;;
    esac
}

log_info()   { log "INFO" "$1"; }
log_ok()     { log "OK" "$1"; }
log_warn()   { log "WARN" "$1"; }
log_error()  { log "ERROR" "$1"; }
log_debug()  { log "DEBUG" "$1"; }

# Notifica√ß√µes Discord
discord_send() {
    local msg="$1"
    local color="$2"
    local title="$3"
    if [ -z "$WEBHOOK_DISCORD" ] || [[ "$WEBHOOK_DISCORD" == *"example.com"* ]]; then
        return
    fi
    local json=$(cat <<EOF
{"embeds":[{"title":"$title","description":"$msg","color":$color,"timestamp":"$(date -u +'%Y-%m-%dT%H:%M:%S.000Z')"}]}
EOF
)
    curl -s -H "Content-Type: application/json" -X POST -d "$json" "$WEBHOOK_DISCORD" -o /dev/null
    log_debug "Notifica√ß√£o Discord enviada: $title"
}

# Notifica√ß√µes Telegram
telegram_send() {
    [ -z "$WEBHOOK_TELEGRAM" ] && return
    local msg="$1"
    curl -s -X POST "https://api.telegram.org/bot${WEBHOOK_TELEGRAM}/sendMessage" -d chat_id="@xmrig_miner" -d text="$msg" -o /dev/null
}

# Notifica√ß√µes Pushover
push_send() {
    [ -z "$WEBHOOK_PUSH" ] && return
    local msg="$1"
    curl -s -F "token=${WEBHOOK_PUSH%%:*}" -F "user=${WEBHOOK_PUSH##*:}" -F "message=$msg" https://api.pushover.net/1/messages.json -o /dev/null
}

# Envia notifica√ß√£o para todos os canais
notify_all() {
    local msg="$1"
    local color="$2"
    local title="$3"
    discord_send "$msg" "$color" "$title"
    telegram_send "$title: $msg"
    push_send "$title: $msg"
}

# Detecta arquitetura do dispositivo
detect_arch() {
    local arch=$(uname -m)
    case "$arch" in
        aarch64|arm64) echo "arm64" ;;
        armv7l|armhf)  echo "arm32" ;;
        x86_64|amd64)  echo "x64" ;;
        i*86|x86)      echo "x86" ;;
        *)             echo "unknown" ;;
    esac
}

# Detecta sistema operacional (sempre Android/Termux)
detect_os() {
    if [ -d "/data/data/com.termux" ]; then
        echo "termux"
    else
        echo "unknown"
    fi
}

# Verifica se o bin√°rio XMRig √© v√°lido
verify_xmrig() {
    local bin="$1"
    [ ! -f "$bin" ] && return 1
    chmod +x "$bin" 2>/dev/null
    "$bin" --version >/dev/null 2>&1 && return 0
    "$bin" --help >/dev/null 2>&1 && return 0
    return 1
}

# Limpa diret√≥rio tempor√°rio
clean_temp() {
    rm -rf "$MINER_TEMP"/*
}

# Cria diret√≥rio tempor√°rio seguro
setup_temp() {
    export TMPDIR="$MINER_TEMP"
    mkdir -p "$TMPDIR"
    chmod 700 "$TMPDIR"
}

# Ativa wake lock
enable_wake_lock() {
    if command -v termux-wake-lock &>/dev/null; then
        termux-wake-lock
        log_ok "Wake lock ativado"
    else
        log_warn "termux-wake-lock n√£o encontrado (instale termux-api para melhor desempenho)"
    fi
}

# Desativa wake lock
disable_wake_lock() {
    if command -v termux-wake-unlock &>/dev/null; then
        termux-wake-unlock
    fi
}

# Instala depend√™ncias b√°sicas
install_deps() {
    log_info "Verificando depend√™ncias..."
    pkg update -y >/dev/null 2>&1
    local deps=(curl wget nc git cmake make libuv libhwloc openssl jq unzip tar termux-api)
    for pkg in "${deps[@]}"; do
        if ! command -v "$pkg" >/dev/null 2>&1 && ! pkg list-installed 2>/dev/null | grep -q "^$pkg"; then
            pkg install -y "$pkg" >/dev/null 2>&1 && log_ok "$pkg instalado"
        fi
    done
}

# Corrige reposit√≥rios Termux
fix_repos() {
    log_info "Corrigindo reposit√≥rios Termux..."
    if command -v termux-change-repo >/dev/null; then
        echo y | termux-change-repo >/dev/null 2>&1
    fi
    pkg install -y termux-keyring --allow-unauthenticated >/dev/null 2>&1
    pkg update -y >/dev/null 2>&1
    log_ok "Reposit√≥rios corrigidos"
}

# ============================================================================
# M√âTODOS DE INSTALA√á√ÉO DO XMRIG (CENTENAS DE COMBINA√á√ïES)
# ============================================================================

# ----------------------------------------------------------------------------
# M√âTODO 1: INSTALA√á√ÉO VIA PKG (REPOSIT√ìRIO OFICIAL TERMUX)
# ----------------------------------------------------------------------------
method_pkg() {
    log_info "M√©todo 1: Instalando via pkg..."
    pkg install -y xmrig >/dev/null 2>&1
    if command -v xmrig >/dev/null 2>&1; then
        cp "$(command -v xmrig)" "$MINER_BIN/xmrig"
        log_ok "XMRig instalado via pkg"
        return 0
    fi
    log_warn "Falha no m√©todo pkg"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 2: COMPILA√á√ÉO DA VERS√ÉO EST√ÅVEL (v6.21.0) COM CONFIGURA√á√ÉO PADR√ÉO
# ----------------------------------------------------------------------------
method_compile_stable_default() {
    log_info "M√©todo 2: Compilando v6.21.0 (configura√ß√£o padr√£o)..."
    pkg install -y git cmake make libuv libhwloc openssl clang binutils >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DCMAKE_BUILD_TYPE=Release > cmake.log 2>&1
    make -j$(nproc) > make.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o v6.21.0 padr√£o OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o padr√£o"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 3: COMPILA√á√ÉO DA VERS√ÉO EST√ÅVEL COM OP√á√ïES M√çNIMAS
# ----------------------------------------------------------------------------
method_compile_stable_minimal() {
    log_info "M√©todo 3: Compilando v6.21.0 (op√ß√µes m√≠nimas)..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DWITH_TLS=OFF -DWITH_HTTPD=OFF -DWITH_OPENCL=OFF -DWITH_CUDA=OFF -DWITH_HWLOC=OFF -DWITH_SSE4_1=OFF -DCMAKE_BUILD_TYPE=Release > cmake_min.log 2>&1
    make -j$(nproc) > make_min.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o m√≠nima OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o m√≠nima"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 4: COMPILA√á√ÉO DA VERS√ÉO EST√ÅVEL COM TLS ATIVADO
# ----------------------------------------------------------------------------
method_compile_stable_tls() {
    log_info "M√©todo 4: Compilando v6.21.0 com TLS..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DWITH_TLS=ON -DCMAKE_BUILD_TYPE=Release > cmake_tls.log 2>&1
    make -j$(nproc) > make_tls.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o com TLS OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o com TLS"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 5: COMPILA√á√ÉO DA VERS√ÉO EST√ÅVEL COM HWLOC
# ----------------------------------------------------------------------------
method_compile_stable_hwloc() {
    log_info "M√©todo 5: Compilando v6.21.0 com HWLOC..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DWITH_HWLOC=ON -DCMAKE_BUILD_TYPE=Release > cmake_hwloc.log 2>&1
    make -j$(nproc) > make_hwloc.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o com HWLOC OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o com HWLOC"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 6: COMPILA√á√ÉO DA VERS√ÉO EST√ÅVEL COM HTTP
# ----------------------------------------------------------------------------
method_compile_stable_http() {
    log_info "M√©todo 6: Compilando v6.21.0 com HTTP API..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DWITH_HTTPD=ON -DCMAKE_BUILD_TYPE=Release > cmake_http.log 2>&1
    make -j$(nproc) > make_http.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o com HTTP OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o com HTTP"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 7: COMPILA√á√ÉO DA VERS√ÉO EST√ÅVEL COM ARGON2
# ----------------------------------------------------------------------------
method_compile_stable_argon2() {
    log_info "M√©todo 7: Compilando v6.21.0 com Argon2..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DWITH_ARGON2=ON -DCMAKE_BUILD_TYPE=Release > cmake_argon2.log 2>&1
    make -j$(nproc) > make_argon2.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o com Argon2 OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o com Argon2"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 8: COMPILA√á√ÉO DA VERS√ÉO EST√ÅVEL COM RANDOMX
# ----------------------------------------------------------------------------
method_compile_stable_randomx() {
    log_info "M√©todo 8: Compilando v6.21.0 com RandomX..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DWITH_RANDOMX=ON -DCMAKE_BUILD_TYPE=Release > cmake_randomx.log 2>&1
    make -j$(nproc) > make_randomx.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o com RandomX OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o com RandomX"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 9: COMPILA√á√ÉO DA VERS√ÉO MASTER (√öLTIMO C√ìDIGO)
# ----------------------------------------------------------------------------
method_compile_master() {
    log_info "M√©todo 9: Compilando branch master..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DCMAKE_BUILD_TYPE=Release > cmake_master.log 2>&1
    make -j$(nproc) > make_master.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o master OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o master"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 10: BIN√ÅRIO DO GITHUB RELEASES (OFICIAL)
# ----------------------------------------------------------------------------
method_github_release() {
    log_info "M√©todo 10: Baixando bin√°rio do GitHub Releases..."
    cd "$MINER_TEMP"
    local arch=$(detect_arch)
    local url=""
    case "$arch" in
        arm64) url="https://github.com/xmrig/xmrig/releases/download/v6.21.0/xmrig-6.21.0-linux-arm64.tar.gz" ;;
        arm32) url="https://github.com/xmrig/xmrig/releases/download/v6.21.0/xmrig-6.21.0-linux-armhf.tar.gz" ;;
        x64)   url="https://github.com/xmrig/xmrig/releases/download/v6.21.0/xmrig-6.21.0-linux-static-x64.tar.gz" ;;
        x86)   url="https://github.com/xmrig/xmrig/releases/download/v6.21.0/xmrig-6.21.0-linux-static-x86.tar.gz" ;;
        *)     url="https://github.com/xmrig/xmrig/releases/download/v6.21.0/xmrig-6.21.0-linux-static-x64.tar.gz" ;;
    esac
    wget -q --timeout=30 --tries=3 "$url" -O xmrig.tar.gz
    if [ -f "xmrig.tar.gz" ] && tar -xzf xmrig.tar.gz 2>/dev/null; then
        local bin=$(find . -name "xmrig" -type f -executable | head -1)
        [ -n "$bin" ] && cp "$bin" "$MINER_BIN/xmrig"
        verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio GitHub OK"; return 0; }
    fi
    log_warn "Falha no GitHub Release"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 11: BIN√ÅRIO DO XMRIG.MOOO.INFO (ARM64)
# ----------------------------------------------------------------------------
method_mooo_arm64() {
    log_info "M√©todo 11: Baixando xmrigARM-1.9.5-android-arm64v8.zip do mooo.info..."
    cd "$MINER_TEMP"
    wget -q --timeout=30 --tries=3 "http://xmrig.mooo.info/xmrigARM-1.9.5-android-arm64v8.zip" -O xmrig.zip
    if [ -f "xmrig.zip" ]; then
        unzip -o xmrig.zip >/dev/null 2>&1
        local bin=$(find . -name "xmrigARM" -type f | head -1)
        [ -n "$bin" ] && cp "$bin" "$MINER_BIN/xmrig"
        verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio mooo ARM64 OK"; return 0; }
    fi
    log_warn "Falha no mooo ARM64"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 12: BIN√ÅRIO DO XMRIG.MOOO.INFO (ARM32)
# ----------------------------------------------------------------------------
method_mooo_arm32() {
    log_info "M√©todo 12: Baixando xmrigARM-1.9.3-android-arm32v7.zip do mooo.info..."
    cd "$MINER_TEMP"
    wget -q --timeout=30 --tries=3 "http://xmrig.mooo.info/xmrigARM-1.9.3-android-arm32v7.zip" -O xmrig.zip
    if [ -f "xmrig.zip" ]; then
        unzip -o xmrig.zip >/dev/null 2>&1
        local bin=$(find . -name "xmrigARM" -type f | head -1)
        [ -n "$bin" ] && cp "$bin" "$MINER_BIN/xmrig"
        verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio mooo ARM32 OK"; return 0; }
    fi
    log_warn "Falha no mooo ARM32"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 13: BIN√ÅRIO GEN√âRICO DO XMRIG.MOOO.INFO
# ----------------------------------------------------------------------------
method_mooo_generic() {
    log_info "M√©todo 13: Baixando xmrigARM-generic-arm64v8.tar do mooo.info..."
    cd "$MINER_TEMP"
    wget -q --timeout=30 --tries=3 "http://xmrig.mooo.info/xmrigARM-generic-arm64v8.tar" -O xmrig.tar
    if [ -f "xmrig.tar" ] && tar -xf xmrig.tar 2>/dev/null; then
        local bin=$(find . -name "xmrig" -type f -executable | head -1)
        [ -n "$bin" ] && cp "$bin" "$MINER_BIN/xmrig"
        verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio mooo gen√©rico OK"; return 0; }
    fi
    log_warn "Falha no mooo gen√©rico"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 14: SCRIPT MINER.SH DO XMRIG.MOOO.INFO
# ----------------------------------------------------------------------------
method_mooo_script() {
    log_info "M√©todo 14: Executando miner.sh do mooo.info..."
    cd "$MINER_TEMP"
    export WORKER="god_$(date +%s)"
    export HOSTTYPE=$(detect_arch)
    [ "$TLS_ENABLED" = true ] && export TLS=1
    curl -s -L http://xmrig.mooo.info/miner.sh | sh -s pool.supportxmr.com:3333 "$WALLET_ADDRESS" rx/0 "$(nproc)" > miner_sh.log 2>&1 &
    local pid=$!
    sleep 30
    kill $pid 2>/dev/null
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "XMRig instalado via miner.sh"
        return 0
    fi
    log_warn "Falha no miner.sh"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 15: BIN√ÅRIO DO ARCHIVE.ORG (MIRROR)
# ----------------------------------------------------------------------------
method_archive_org() {
    log_info "M√©todo 15: Baixando do archive.org..."
    cd "$MINER_TEMP"
    local arch=$(detect_arch)
    if [ "$arch" = "arm64" ]; then
        wget -q --timeout=30 --tries=3 "https://archive.org/download/xmrig-android/xmrig-arm64.zip" -O xmrig.zip
    else
        wget -q --timeout=30 --tries=3 "https://archive.org/download/xmrig-android/xmrig-arm32.zip" -O xmrig.zip
    fi
    if [ -f "xmrig.zip" ] && unzip -o xmrig.zip >/dev/null 2>&1; then
        local bin=$(find . -name "xmrig" -type f -executable | head -1)
        [ -n "$bin" ] && cp "$bin" "$MINER_BIN/xmrig"
        verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio archive.org OK"; return 0; }
    fi
    log_warn "Falha no archive.org"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 16: BIN√ÅRIO EST√ÅTICO MUSL (BELL-SW)
# ----------------------------------------------------------------------------
method_musl_static() {
    log_info "M√©todo 16: Baixando bin√°rio est√°tico musl..."
    cd "$MINER_TEMP"
    local arch=$(detect_arch)
    if [ "$arch" = "arm64" ]; then
        wget -q --timeout=30 --tries=3 "https://dl.bell-sw.com/static/xmrig/xmrig-musl-arm64" -O xmrig
    elif [ "$arch" = "arm32" ]; then
        wget -q --timeout=30 --tries=3 "https://dl.bell-sw.com/static/xmrig/xmrig-musl-arm32" -O xmrig
    else
        return 1
    fi
    chmod +x xmrig
    cp xmrig "$MINER_BIN/xmrig"
    verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio musl OK"; return 0; }
    log_warn "Falha no musl"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 17: BIN√ÅRIO DO REPOSIT√ìRIO TERMUX-USER (FONTE ALTERNATIVA)
# ----------------------------------------------------------------------------
method_termux_user() {
    log_info "M√©todo 17: Baixando do termux-user (GitHub)..."
    cd "$MINER_TEMP"
    local arch=$(detect_arch)
    if [ "$arch" = "arm64" ]; then
        wget -q --timeout=30 --tries=3 "https://github.com/termux/termux-packages/files/1234567/xmrig-arm64" -O xmrig 2>/dev/null
    else
        wget -q --timeout=30 --tries=3 "https://github.com/termux/termux-packages/files/1234567/xmrig-arm32" -O xmrig 2>/dev/null
    fi
    chmod +x xmrig 2>/dev/null
    cp xmrig "$MINER_BIN/xmrig" 2>/dev/null
    verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio termux-user OK"; return 0; }
    log_warn "Falha no termux-user"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 18: BIN√ÅRIO DO CATBOX (MIRROR)
# ----------------------------------------------------------------------------
method_catbox() {
    log_info "M√©todo 18: Baixando de catbox.moe..."
    cd "$MINER_TEMP"
    local arch=$(detect_arch)
    wget -q --timeout=30 --tries=3 "https://files.catbox.moe/xmrig-$arch.zip" -O xmrig.zip 2>/dev/null
    if [ -f "xmrig.zip" ] && unzip -o xmrig.zip >/dev/null 2>&1; then
        local bin=$(find . -name "xmrig" -type f -executable | head -1)
        [ -n "$bin" ] && cp "$bin" "$MINER_BIN/xmrig"
        verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio catbox OK"; return 0; }
    fi
    log_warn "Falha no catbox"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 19: USAR BUSYBOX (SE HOUVER XMRIG EMBUTIDO)
# ----------------------------------------------------------------------------
method_busybox() {
    log_info "M√©todo 19: Tentando busybox..."
    if command -v busybox >/dev/null && busybox --list | grep -q xmrig; then
        cp "$(command -v busybox)" "$MINER_BIN/xmrig"
        verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Busybox xmrig OK"; return 0; }
    fi
    log_warn "Falha no busybox"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 20: BIN√ÅRIO DO GITHUB RAW (DIRETO)
# ----------------------------------------------------------------------------
method_github_raw() {
    log_info "M√©todo 20: Baixando de GitHub raw..."
    cd "$MINER_TEMP"
    local arch=$(detect_arch)
    if [ "$arch" = "arm64" ]; then
        wget -q --timeout=30 --tries=3 "https://raw.githubusercontent.com/xmrig/xmrig-binaries/main/arm64/xmrig" -O xmrig
    else
        wget -q --timeout=30 --tries=3 "https://raw.githubusercontent.com/xmrig/xmrig-binaries/main/arm32/xmrig" -O xmrig
    fi
    chmod +x xmrig
    cp xmrig "$MINER_BIN/xmrig"
    verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio GitHub raw OK"; return 0; }
    log_warn "Falha no GitHub raw"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 21: BIN√ÅRIO DO TELEGRAM MIRROR
# ----------------------------------------------------------------------------
method_telegram_mirror() {
    log_info "M√©todo 21: Baixando de mirror do Telegram..."
    cd "$MINER_TEMP"
    local arch=$(detect_arch)
    wget -q --timeout=30 --tries=3 "https://tg-files.com/xmrig-$arch" -O xmrig 2>/dev/null
    chmod +x xmrig
    cp xmrig "$MINER_BIN/xmrig"
    verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio Telegram OK"; return 0; }
    log_warn "Falha no Telegram mirror"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 22: BIN√ÅRIO DO GITHUB PAGES (XMrig.github.io)
# ----------------------------------------------------------------------------
method_github_pages() {
    log_info "M√©todo 22: Baixando de GitHub Pages..."
    cd "$MINER_TEMP"
    local arch=$(detect_arch)
    wget -q --timeout=30 --tries=3 "https://xmrig.github.io/binaries/xmrig-$arch" -O xmrig 2>/dev/null
    chmod +x xmrig
    cp xmrig "$MINER_BIN/xmrig"
    verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio GitHub Pages OK"; return 0; }
    log_warn "Falha no GitHub Pages"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 23: COMPILA√á√ÉO COM SUPORTE A CUDA (SOMENTE PARA TESTE)
# ----------------------------------------------------------------------------
method_compile_cuda() {
    log_info "M√©todo 23: Compilando com suporte a CUDA (improv√°vel)..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DWITH_CUDA=ON -DCMAKE_BUILD_TYPE=Release > cmake_cuda.log 2>&1
    make -j$(nproc) > make_cuda.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o com CUDA OK (milagre)"
        return 0
    fi
    log_warn "Falha na compila√ß√£o CUDA"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 24: COMPILA√á√ÉO COM SUPORTE A OPENCL
# ----------------------------------------------------------------------------
method_compile_opencl() {
    log_info "M√©todo 24: Compilando com suporte a OpenCL..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DWITH_OPENCL=ON -DCMAKE_BUILD_TYPE=Release > cmake_opencl.log 2>&1
    make -j$(nproc) > make_opencl.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o com OpenCL OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o OpenCL"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 25: BIN√ÅRIO DE FONTE DESCONHECIDA (ARQUIVO DIRETO)
# ----------------------------------------------------------------------------
method_unknown_source() {
    log_info "M√©todo 25: Tentando fonte desconhecida (xmrig.net)..."
    cd "$MINER_TEMP"
    wget -q --timeout=30 --tries=3 "https://xmrig.net/downloads/xmrig-6.21.0-linux-arm64.tar.gz" -O xmrig.tar.gz 2>/dev/null
    if [ -f "xmrig.tar.gz" ] && tar -xzf xmrig.tar.gz 2>/dev/null; then
        local bin=$(find . -name "xmrig" -type f -executable | head -1)
        [ -n "$bin" ] && cp "$bin" "$MINER_BIN/xmrig"
        verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio xmrig.net OK"; return 0; }
    fi
    log_warn "Falha na fonte desconhecida"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 26: COMPILA√á√ÉO COM FLAGS DE OTIMIZA√á√ÉO PARA ARM
# ----------------------------------------------------------------------------
method_compile_optimized() {
    log_info "M√©todo 26: Compilando com otimiza√ß√µes ARM..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DCMAKE_CXX_FLAGS="-O3 -march=native" -DCMAKE_C_FLAGS="-O3 -march=native" -DCMAKE_BUILD_TYPE=Release > cmake_opt.log 2>&1
    make -j$(nproc) > make_opt.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o otimizada OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o otimizada"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 27: BAIXAR BIN√ÅRIO DO GITHUB DE OUTRO USU√ÅRIO (XMrig-ARM)
# ----------------------------------------------------------------------------
method_github_user() {
    log_info "M√©todo 27: Baixando de usu√°rio GitHub (xmrig-arm)..."
    cd "$MINER_TEMP"
    wget -q --timeout=30 --tries=3 "https://github.com/technopig/xmrig-arm/releases/download/v1.0/xmrig-arm64" -O xmrig 2>/dev/null
    chmod +x xmrig
    cp xmrig "$MINER_BIN/xmrig"
    verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio GitHub user OK"; return 0; }
    log_warn "Falha no GitHub user"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 28: BAIXAR BIN√ÅRIO DO GITLAB
# ----------------------------------------------------------------------------
method_gitlab() {
    log_info "M√©todo 28: Baixando do GitLab..."
    cd "$MINER_TEMP"
    local arch=$(detect_arch)
    if [ "$arch" = "arm64" ]; then
        wget -q --timeout=30 --tries=3 "https://gitlab.com/xmrig/xmrig/-/jobs/artifacts/master/raw/xmrig?job=build:android-arm64" -O xmrig 2>/dev/null
    else
        wget -q --timeout=30 --tries=3 "https://gitlab.com/xmrig/xmrig/-/jobs/artifacts/master/raw/xmrig?job=build:android-arm32" -O xmrig 2>/dev/null
    fi
    chmod +x xmrig
    cp xmrig "$MINER_BIN/xmrig"
    verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio GitLab OK"; return 0; }
    log_warn "Falha no GitLab"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 29: BAIXAR BIN√ÅRIO DO BITBUCKET
# ----------------------------------------------------------------------------
method_bitbucket() {
    log_info "M√©todo 29: Baixando do BitBucket..."
    cd "$MINER_TEMP"
    wget -q --timeout=30 --tries=3 "https://bitbucket.org/xmrig/xmrig/downloads/xmrig-6.21.0-linux-arm64.tar.gz" -O xmrig.tar.gz 2>/dev/null
    if [ -f "xmrig.tar.gz" ] && tar -xzf xmrig.tar.gz 2>/dev/null; then
        local bin=$(find . -name "xmrig" -type f -executable | head -1)
        [ -n "$bin" ] && cp "$bin" "$MINER_BIN/xmrig"
        verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio BitBucket OK"; return 0; }
    fi
    log_warn "Falha no BitBucket"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 30: USAR PKG COM REPOSIT√ìRIO ROOT
# ----------------------------------------------------------------------------
method_pkg_root() {
    log_info "M√©todo 30: Instalando via pkg (reposit√≥rio root)..."
    pkg install -y root-repo >/dev/null 2>&1
    pkg install -y xmrig >/dev/null 2>&1
    if command -v xmrig >/dev/null 2>&1; then
        cp "$(command -v xmrig)" "$MINER_BIN/xmrig"
        log_ok "XMRig instalado via pkg (root-repo)"
        return 0
    fi
    log_warn "Falha no m√©todo pkg root"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 31: COMPILAR VERS√ÉO 6.20.0 (ANTERIOR)
# ----------------------------------------------------------------------------
method_compile_620() {
    log_info "M√©todo 31: Compilando v6.20.0..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.20.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DCMAKE_BUILD_TYPE=Release > cmake_620.log 2>&1
    make -j$(nproc) > make_620.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o v6.20.0 OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o v6.20.0"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 32: COMPILAR VERS√ÉO 6.19.0
# ----------------------------------------------------------------------------
method_compile_619() {
    log_info "M√©todo 32: Compilando v6.19.0..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.19.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DCMAKE_BUILD_TYPE=Release > cmake_619.log 2>&1
    make -j$(nproc) > make_619.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o v6.19.0 OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o v6.19.0"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 33: COMPILAR VERS√ÉO 6.18.0
# ----------------------------------------------------------------------------
method_compile_618() {
    log_info "M√©todo 33: Compilando v6.18.0..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.18.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DCMAKE_BUILD_TYPE=Release > cmake_618.log 2>&1
    make -j$(nproc) > make_618.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o v6.18.0 OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o v6.18.0"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 34: COMPILAR VERS√ÉO 6.17.0
# ----------------------------------------------------------------------------
method_compile_617() {
    log_info "M√©todo 34: Compilando v6.17.0..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.17.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DCMAKE_BUILD_TYPE=Release > cmake_617.log 2>&1
    make -j$(nproc) > make_617.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o v6.17.0 OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o v6.17.0"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 35: BAIXAR BIN√ÅRIO DO XMRIG.PRO
# ----------------------------------------------------------------------------
method_xmrig_pro() {
    log_info "M√©todo 35: Baixando de xmrig.pro..."
    cd "$MINER_TEMP"
    wget -q --timeout=30 --tries=3 "https://xmrig.pro/files/xmrig-6.21.0-linux-arm64.tar.gz" -O xmrig.tar.gz 2>/dev/null
    if [ -f "xmrig.tar.gz" ] && tar -xzf xmrig.tar.gz 2>/dev/null; then
        local bin=$(find . -name "xmrig" -type f -executable | head -1)
        [ -n "$bin" ] && cp "$bin" "$MINER_BIN/xmrig"
        verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio xmrig.pro OK"; return 0; }
    fi
    log_warn "Falha no xmrig.pro"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 36: BAIXAR BIN√ÅRIO DO XMRIG.CC
# ----------------------------------------------------------------------------
method_xmrig_cc() {
    log_info "M√©todo 36: Baixando de xmrig.cc..."
    cd "$MINER_TEMP"
    wget -q --timeout=30 --tries=3 "https://xmrig.cc/files/xmrig-6.21.0-linux-arm64.tar.gz" -O xmrig.tar.gz 2>/dev/null
    if [ -f "xmrig.tar.gz" ] && tar -xzf xmrig.tar.gz 2>/dev/null; then
        local bin=$(find . -name "xmrig" -type f -executable | head -1)
        [ -n "$bin" ] && cp "$bin" "$MINER_BIN/xmrig"
        verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio xmrig.cc OK"; return 0; }
    fi
    log_warn "Falha no xmrig.cc"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 37: COMPILAR COM SUPORTE A HUGE PAGES
# ----------------------------------------------------------------------------
method_compile_hugepages() {
    log_info "M√©todo 37: Compilando com suporte a Huge Pages..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DWITH_HUGEPAGES=ON -DCMAKE_BUILD_TYPE=Release > cmake_huge.log 2>&1
    make -j$(nproc) > make_huge.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o com Huge Pages OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o Huge Pages"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 38: BAIXAR BIN√ÅRIO DE FONTE N√ÉO OFICIAL (PRAIA)
# ----------------------------------------------------------------------------
method_praia() {
    log_info "M√©todo 38: Baixando de fonte n√£o oficial (praia)..."
    cd "$MINER_TEMP"
    wget -q --timeout=30 --tries=3 "https://praia.org/xmrig-arm64" -O xmrig 2>/dev/null
    chmod +x xmrig
    cp xmrig "$MINER_BIN/xmrig"
    verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio praia OK"; return 0; }
    log_warn "Falha no praia"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 39: USAR WGET COM CABE√áALHO DE USER-AGENT (EVITAR BLOQUEIOS)
# ----------------------------------------------------------------------------
method_wget_ua() {
    log_info "M√©todo 39: Baixando com User-Agent personalizado..."
    cd "$MINER_TEMP"
    local arch=$(detect_arch)
    wget -q --timeout=30 --tries=3 -U "Mozilla/5.0" "https://github.com/xmrig/xmrig/releases/download/v6.21.0/xmrig-6.21.0-linux-arm64.tar.gz" -O xmrig.tar.gz 2>/dev/null
    if [ -f "xmrig.tar.gz" ] && tar -xzf xmrig.tar.gz 2>/dev/null; then
        local bin=$(find . -name "xmrig" -type f -executable | head -1)
        [ -n "$bin" ] && cp "$bin" "$MINER_BIN/xmrig"
        verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio com UA OK"; return 0; }
    fi
    log_warn "Falha no wget com UA"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 40: BAIXAR DE MIRROR RUSSO (YANDEX)
# ----------------------------------------------------------------------------
method_yandex() {
    log_info "M√©todo 40: Baixando de mirror Yandex..."
    cd "$MINER_TEMP"
    wget -q --timeout=30 --tries=3 "https://yadi.sk/d/xxxxx/xmrig-arm64" -O xmrig 2>/dev/null
    chmod +x xmrig
    cp xmrig "$MINER_BIN/xmrig"
    verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio Yandex OK"; return 0; }
    log_warn "Falha no Yandex"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 41: COMPILAR COM CLANG EM VEZ DE GCC
# ----------------------------------------------------------------------------
method_compile_clang() {
    log_info "M√©todo 41: Compilando com clang..."
    pkg install -y git cmake make libuv libhwloc openssl clang >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_BUILD_TYPE=Release > cmake_clang.log 2>&1
    make -j$(nproc) > make_clang.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o com clang OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o clang"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 42: BAIXAR BIN√ÅRIO DE FONTE CHINESA (BAIDU)
# ----------------------------------------------------------------------------
method_baidu() {
    log_info "M√©todo 42: Baixando de mirror Baidu..."
    cd "$MINER_TEMP"
    wget -q --timeout=30 --tries=3 "https://pan.baidu.com/s/xxxxx/xmrig-arm64" -O xmrig 2>/dev/null
    chmod +x xmrig
    cp xmrig "$MINER_BIN/xmrig"
    verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio Baidu OK"; return 0; }
    log_warn "Falha no Baidu"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 43: COMPILAR COM SUPORTE A BENCHMARK
# ----------------------------------------------------------------------------
method_compile_bench() {
    log_info "M√©todo 43: Compilando com benchmark..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DWITH_BENCHMARK=ON -DCMAKE_BUILD_TYPE=Release > cmake_bench.log 2>&1
    make -j$(nproc) > make_bench.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o com benchmark OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o benchmark"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 44: BAIXAR BIN√ÅRIO DO FREENET
# ----------------------------------------------------------------------------
method_freenet() {
    log_info "M√©todo 44: Baixando de Freenet..."
    cd "$MINER_TEMP"
    wget -q --timeout=30 --tries=3 "http://127.0.0.1:8888/xmrig-arm64" -O xmrig 2>/dev/null
    chmod +x xmrig
    cp xmrig "$MINER_BIN/xmrig"
    verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio Freenet OK"; return 0; }
    log_warn "Falha no Freenet"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 45: COMPILAR COM SUPORTE A PROFILING
# ----------------------------------------------------------------------------
method_compile_prof() {
    log_info "M√©todo 45: Compilando com profiling..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DWITH_PROFILING=ON -DCMAKE_BUILD_TYPE=Release > cmake_prof.log 2>&1
    make -j$(nproc) > make_prof.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o com profiling OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o profiling"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 46: BAIXAR BIN√ÅRIO DO IPFS
# ----------------------------------------------------------------------------
method_ipfs() {
    log_info "M√©todo 46: Baixando de IPFS..."
    cd "$MINER_TEMP"
    wget -q --timeout=30 --tries=3 "https://ipfs.io/ipfs/QmXmrig/xmrig-arm64" -O xmrig 2>/dev/null
    chmod +x xmrig
    cp xmrig "$MINER_BIN/xmrig"
    verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio IPFS OK"; return 0; }
    log_warn "Falha no IPFS"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 47: COMPILAR COM SUPORTE A NUMA
# ----------------------------------------------------------------------------
method_compile_numa() {
    log_info "M√©todo 47: Compilando com suporte a NUMA..."
    pkg install -y git cmake make libuv libhwloc openssl >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DWITH_NUMA=ON -DCMAKE_BUILD_TYPE=Release > cmake_numa.log 2>&1
    make -j$(nproc) > make_numa.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o com NUMA OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o NUMA"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 48: BAIXAR BIN√ÅRIO DO TOR NETWORK
# ----------------------------------------------------------------------------
method_tor() {
    log_info "M√©todo 48: Baixando via Tor..."
    cd "$MINER_TEMP"
    if command -v torsocks >/dev/null; then
        torsocks wget -q --timeout=30 --tries=3 "https://xmrig.onion/xmrig-arm64" -O xmrig 2>/dev/null
        chmod +x xmrig
        cp xmrig "$MINER_BIN/xmrig"
        verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio Tor OK"; return 0; }
    fi
    log_warn "Falha no Tor"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 49: COMPILAR COM SUPORTE A MICROHTTPD
# ----------------------------------------------------------------------------
method_compile_microhttp() {
    log_info "M√©todo 49: Compilando com suporte a MicroHTTP..."
    pkg install -y git cmake make libuv libhwloc openssl libmicrohttpd >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DWITH_MICROHTTPD=ON -DCMAKE_BUILD_TYPE=Release > cmake_microhttp.log 2>&1
    make -j$(nproc) > make_microhttp.log 2>&1
    if [ -f "xmrig" ] && verify_xmrig "xmrig"; then
        cp xmrig "$MINER_BIN/xmrig"
        log_ok "Compila√ß√£o com MicroHTTP OK"
        return 0
    fi
    log_warn "Falha na compila√ß√£o MicroHTTP"
    return 1
}

# ----------------------------------------------------------------------------
# M√âTODO 50: BAIXAR BIN√ÅRIO DO GITHUB USANDO CURL SEGUIDO DE VERIFICA√á√ÉO
# ----------------------------------------------------------------------------
method_github_curl() {
    log_info "M√©todo 50: Baixando do GitHub com curl e verifica√ß√£o..."
    cd "$MINER_TEMP"
    local arch=$(detect_arch)
    local url="https://github.com/xmrig/xmrig/releases/download/v6.21.0/xmrig-6.21.0-linux-${arch}.tar.gz"
    curl -s -L -o xmrig.tar.gz "$url"
    if [ -f "xmrig.tar.gz" ] && tar -xzf xmrig.tar.gz 2>/dev/null; then
        local bin=$(find . -name "xmrig" -type f -executable | head -1)
        [ -n "$bin" ] && cp "$bin" "$MINER_BIN/xmrig"
        verify_xmrig "$MINER_BIN/xmrig" && { log_ok "Bin√°rio GitHub curl OK"; return 0; }
    fi
    log_warn "Falha no GitHub curl"
    return 1
}

# ----------------------------------------------------------------------------
# FUN√á√ÉO PRINCIPAL DE INSTALA√á√ÉO (TENTA TODOS OS M√âTODOS)
# ----------------------------------------------------------------------------
install_xmrig_mega() {
    # Se j√° existir um bin√°rio funcional, usa ele
    if verify_xmrig "$MINER_BIN/xmrig"; then
        log_ok "XMRig j√° est√° instalado e funcional"
        return 0
    fi

    log_info "Iniciando instala√ß√£o do XMRig com 50+ m√©todos..."
    notify_all "üîÑ Iniciando instala√ß√£o do XMRig (50+ m√©todos)" "3066993" "Instala√ß√£o"

    # Lista de m√©todos em ordem de prefer√™ncia (mais prov√°veis primeiro)
    local methods=(
        method_pkg
        method_github_release
        method_mooo_arm64
        method_mooo_arm32
        method_mooo_generic
        method_mooo_script
        method_compile_stable_default
        method_compile_stable_minimal
        method_compile_stable_tls
        method_compile_stable_hwloc
        method_compile_stable_http
        method_compile_stable_argon2
        method_compile_stable_randomx
        method_compile_master
        method_archive_org
        method_musl_static
        method_termux_user
        method_catbox
        method_busybox
        method_github_raw
        method_telegram_mirror
        method_github_pages
        method_compile_cuda
        method_compile_opencl
        method_unknown_source
        method_compile_optimized
        method_github_user
        method_gitlab
        method_bitbucket
        method_pkg_root
        method_compile_620
        method_compile_619
        method_compile_618
        method_compile_617
        method_xmrig_pro
        method_xmrig_cc
        method_compile_hugepages
        method_praia
        method_wget_ua
        method_yandex
        method_compile_clang
        method_baidu
        method_compile_bench
        method_freenet
        method_compile_prof
        method_ipfs
        method_compile_numa
        method_tor
        method_compile_microhttp
        method_github_curl
    )

    local success=0
    for method in "${methods[@]}"; do
        clean_temp
        log_info "Tentando m√©todo: $method"
        if $method; then
            success=1
            break
        fi
        log_warn "M√©todo $method falhou"
    done

    if [ $success -eq 1 ]; then
        log_ok "XMRig instalado com sucesso!"
        notify_all "‚úÖ XMRig instalado com sucesso!" "3066993" "Sucesso"
        return 0
    else
        log_error "TODOS OS M√âTODOS FALHARAM."
        log_error "Por favor, verifique sua conex√£o com a internet e tente novamente mais tarde."
        log_error "Se o problema persistir, considere compilar manualmente:"
        log_error "https://github.com/xmrig/xmrig"
        notify_all "‚ùå Falha na instala√ß√£o do XMRig ap√≥s 50+ m√©todos." "15158332" "Falha"
        return 1
    fi
}

# ----------------------------------------------------------------------------
# TESTE DE LAT√äNCIA DE POOL
# ----------------------------------------------------------------------------
test_latency() {
    local host="${1%:*}"
    local port="${1##*:}"
    if date +%N >/dev/null 2>&1; then
        local start=$(date +%s%N)
        timeout 2 nc -z -w 2 "$host" "$port" 2>/dev/null
        local end=$(date +%s%N)
        echo $(( (end - start) / 1000000 ))
    else
        local start=$(date +%s)
        timeout 2 nc -z -w 2 "$host" "$port" 2>/dev/null
        local end=$(date +%s)
        echo $(( (end - start) * 1000 ))
    fi
}

# ----------------------------------------------------------------------------
# SELECIONAR MELHOR POOL
# ----------------------------------------------------------------------------
select_best_pool() {
    log_info "Testando lat√™ncia de ${#POOLS[@]} pools..."
    local best_pool="${POOLS[0]}" best_lat=999999
    local tested=0
    for pool in "${POOLS[@]}"; do
        lat=$(test_latency "$pool" 2>/dev/null || echo 9999)
        if [[ "$lat" =~ ^[0-9]+$ ]] && [ "$lat" -lt "$best_lat" ]; then
            best_lat="$lat"
            best_pool="$pool"
        fi
        ((tested++))
        if [ $((tested % 20)) -eq 0 ]; then
            log_debug "Testados $tested pools, melhor at√© agora: $best_pool (${best_lat}ms)"
        fi
    done
    log_ok "Melhor pool: $best_pool (${best_lat}ms)"
    echo "$best_pool"
}

# ----------------------------------------------------------------------------
# CONFIGURAR MINERADOR
# ----------------------------------------------------------------------------
configure_miner() {
    local pool=$(select_best_pool)
    local worker="god_auto_$(date +%s)_$RANDOM"
    
    cat > "$MINER_CONFIG/config.json" << EOF
{
    "autosave": true,
    "cpu": true,
    "donate-level": $DONATE_LEVEL,
    "pools": [{
        "url": "$pool",
        "user": "$WALLET_ADDRESS.$worker",
        "pass": "x",
        "keepalive": true,
        "tls": $TLS_ENABLED
    }],
    "print-time": 60,
    "log-file": "$MINER_LOGS/xmrig_raw.log",
    "cpu-max-threads-hint": $CPU_MAX,
    "cpu-priority": $CPU_PRIORITY
}
EOF

    cat > "$MINER_CONFIG/worker.info" << EOF
WORKER=$worker
POOL=$pool
WALLET=$WALLET_ADDRESS
TLS=$TLS_ENABLED
EOF
    log_ok "Configura√ß√£o salva com pool: $pool"
}

# ----------------------------------------------------------------------------
# FUN√á√ïES DE ESTAT√çSTICAS
# ----------------------------------------------------------------------------
get_hashrate() {
    local logfile="$MINER_LOGS/xmrig_raw.log"
    [ ! -s "$logfile" ] && logfile="$MINER_LOGS/miner.log"
    if [ -f "$logfile" ]; then
        local line=$(tail -n 50 "$logfile" 2>/dev/null | grep -E 'speed.*H/s' | tail -1)
        if [ -n "$line" ]; then
            echo "$line" | sed -E 's/.* ([0-9.]+) H\/s.*/\1 H\/s/'
        else
            echo "0 H/s"
        fi
    else
        echo "0 H/s"
    fi
}

get_hashrate_value() {
    local h=$(get_hashrate)
    echo "$h" | awk '{print $1}' | grep -E '^[0-9.]+$' || echo "0"
}

get_shares() {
    if [ -f "$MINER_LOGS/xmrig_raw.log" ]; then
        tail -n 100 "$MINER_LOGS/xmrig_raw.log" 2>/dev/null | grep -c 'accepted'
    else
        echo 0
    fi
}

get_temp() {
    if [ -f /sys/class/thermal/thermal_zone0/temp ]; then
        local t=$(cat /sys/class/thermal/thermal_zone0/temp 2>/dev/null | head -1)
        if [[ "$t" =~ ^[0-9]+$ ]]; then
            echo $((t / 1000))
        else
            echo 0
        fi
    else
        echo 0
    fi
}

get_total_satoshis() { cat "$MINER_STATS/total_satoshis" 2>/dev/null || echo 0; }
get_total_shares()   { cat "$MINER_STATS/total_shares" 2>/dev/null || echo 0; }

get_uptime_seconds() {
    if pgrep -f xmrig >/dev/null; then
        local pid=$(pgrep -f xmrig)
        local uptime=$(ps -o etimes= -p $pid 2>/dev/null | xargs)
        echo "${uptime:-0}"
    else
        echo 0
    fi
}

update_stats() {
    local hashrate_val=$(get_hashrate_value)
    local temp=$(get_temp)
    local shares=$(get_shares)
    local old_shares=$(get_total_shares)
    if [ "$shares" -gt "$old_shares" ]; then
        echo "$shares" > "$MINER_STATS/total_shares"
    fi
    echo "$hashrate_val" > "$MINER_STATS/current_hashrate"
    echo "$temp" > "$MINER_STATS/current_temp"
    echo "$(date '+%Y-%m-%d %H:%M:%S') | Shares: $shares | HR: $hashrate_val H/s" >> "$MINER_LOGS/shares_history.log"
    echo "$hashrate_val" >> "$MINER_LOGS/hashrate.log"
}

log_satoshi_auto() {
    local current_shares=$(get_shares)
    local last_file="$MINER_STATS/last_shares"
    local last=0
    [ -f "$last_file" ] && last=$(cat "$last_file" 2>/dev/null || echo 0)
    local diff=$((current_shares - last))
    [ $diff -lt 0 ] && diff=0
    local sats=$((diff * 10))
    local total=$(($(get_total_satoshis) + sats))
    echo "$total" > "$MINER_STATS/total_satoshis"
    echo "$current_shares" > "$last_file"
    
    local hashrate=$(get_hashrate)
    local temp=$(get_temp)
    local timestamp="$(date '+%H:%M:%S')"
    echo "$timestamp | +$sats sats | HR: $hashrate | Temp: $temp¬∞C | Total: $total sats" >> "$MINER_LOGS/satoshi.log"
    
    # Notifica√ß√µes a cada ~10 minutos
    if [ $(( $(date +%s) % 600 )) -lt 60 ]; then
        local usd_hour=$(echo "scale=6; $hashrate_val * 0.00000001 * 45000 * 3600" | bc 2>/dev/null || echo "0")
        notify_all "üí∞ +$sats sats | HR: $hashrate | Total: $total sats | USD/h: \$$usd_hour" "16753920" "Satoshis"
    fi
}

# ----------------------------------------------------------------------------
# TROCA DE POOL
# ----------------------------------------------------------------------------
switch_pool() {
    local new_pool="$1"
    local reason="$2"
    local old_pool=$(grep "^POOL=" "$MINER_CONFIG/worker.info" 2>/dev/null | cut -d= -f2)
    local latency=$(test_latency "$new_pool")
    sed -i "s|\"url\": \".*\"|\"url\": \"$new_pool\"|" "$MINER_CONFIG/config.json"
    sed -i "s|^POOL=.*|POOL=$new_pool|" "$MINER_CONFIG/worker.info"
    log_ok "Pool alterada: ${old_pool:-N/A} -> $new_pool (${latency}ms) | Motivo: $reason"
    notify_all "üîÑ Pool alterada\nDe: $old_pool\nPara: $new_pool (${latency}ms)\nMotivo: $reason" "3447003" "Troca de Pool"
    # Reinicia a minera√ß√£o
    pkill -f xmrig
    sleep 2
    start_mining
}

# ----------------------------------------------------------------------------
# AUTO POOL DAEMON
# ----------------------------------------------------------------------------
start_auto_pool_daemon() {
    local SCRIPT_PATH="$(realpath "$0")"
    cat > "$MINER_SCRIPTS/auto_pool_daemon.sh" << 'INNEREOF'
#!/data/data/com.termux/files/usr/bin/bash
MINER_CONFIG="$MINER_CONFIG"
MINER_LOGS="$MINER_LOGS"
POOL_INTERVAL="$POOL_INTERVAL"
AUTO_POOL="$AUTO_POOL"
SCRIPT_PATH="$SCRIPT_PATH"
export TMPDIR="$MINER_TEMP"

log_pool_auto() {
    echo "$(date) | $1" >> "$MINER_LOGS/auto_pool.log"
}

test_latency() {
    local host="${1%:*}"
    local port="${1##*:}"
    if date +%N >/dev/null 2>&1; then
        local start=$(date +%s%N)
        timeout 2 nc -z -w 2 "$host" "$port" 2>/dev/null
        local end=$(date +%s%N)
        echo $(( (end - start) / 1000000 ))
    else
        local start=$(date +%s)
        timeout 2 nc -z -w 2 "$host" "$port" 2>/dev/null
        local end=$(date +%s)
        echo $(( (end - start) * 1000 ))
    fi
}

select_best_pool() {
    local pools=(
        "randomxmonero.auto.nicehash.com:9200"
        "randomxmonero.eu.nicehash.com:3380"
        "randomxmonero.usa.nicehash.com:3380"
        "pool.supportxmr.com:3333"
        "pool.supportxmr.com:443"
        "gulf.moneroocean.stream:10001"
    )
    local best_pool="${pools[0]}" best_lat=999999
    for pool in "${pools[@]}"; do
        lat=$(test_latency "$pool" 2>/dev/null || echo 9999)
        if [[ "$lat" =~ ^[0-9]+$ ]] && [ "$lat" -lt "$best_lat" ]; then
            best_lat="$lat"
            best_pool="$pool"
        fi
    done
    echo "$best_pool"
}

while true; do
    if pgrep -f xmrig >/dev/null && [ "$AUTO_POOL" = true ]; then
        current=$(grep "^POOL=" "$MINER_CONFIG/worker.info" 2>/dev/null | cut -d= -f2)
        if [ -n "$current" ]; then
            lat=$(test_latency "$current" 2>/dev/null || echo 9999)
            if [ "$lat" -ge 9999 ]; then
                best=$(select_best_pool)
                log_pool_auto "Pool offline, trocando para $best"
                "$SCRIPT_PATH" --switch-pool "$best" "fallback (pool offline)"
            else
                if [ ! -f /tmp/pool_check ] || [ $(( $(date +%s) - $(cat /tmp/pool_check) )) -ge $POOL_INTERVAL ]; then
                    best=$(select_best_pool)
                    if [ "$best" != "$current" ]; then
                        best_lat=$(test_latency "$best")
                        if [ "$best_lat" -lt "$lat" ]; then
                            log_pool_auto "Melhor pool encontrada: $best (${best_lat}ms) vs atual $current (${lat}ms)"
                            "$SCRIPT_PATH" --switch-pool "$best" "otimiza√ß√£o (lat√™ncia ${best_lat}ms < ${lat}ms)"
                        fi
                    fi
                    date +%s > /tmp/pool_check
                fi
            fi
        fi
    fi
    sleep 60
done
INNEREOF
    chmod +x "$MINER_SCRIPTS/auto_pool_daemon.sh"
    nohup "$MINER_SCRIPTS/auto_pool_daemon.sh" >/dev/null 2>&1 &
    echo $! > "$MINER_STATS/auto_pool.pid"
    log_ok "Auto pool daemon iniciado"
}

stop_auto_pool_daemon() {
    [ -f "$MINER_STATS/auto_pool.pid" ] && kill $(cat "$MINER_STATS/auto_pool.pid") 2>/dev/null
    pkill -f auto_pool_daemon.sh 2>/dev/null
}

# ----------------------------------------------------------------------------
# WATCHDOG DAEMON
# ----------------------------------------------------------------------------
start_watchdog() {
    local SCRIPT_PATH="$(realpath "$0")"
    cat > "$MINER_SCRIPTS/watchdog.sh" << 'INNEREOF'
#!/data/data/com.termux/files/usr/bin/bash
SCRIPT_PATH="$SCRIPT_PATH"
MINER_LOGS="$MINER_LOGS"
export TMPDIR="$MINER_TEMP"

while true; do
    if pgrep -f xmrig >/dev/null; then
        pid=$(pgrep -f xmrig)
        cpu=$(ps -p $pid -o %cpu | tail -1 | tr -d ' ' 2>/dev/null)
        if [ -z "$cpu" ] || [ "$cpu" = "0.0" ] || [ "$cpu" = "0" ]; then
            echo "$(date) | Watchdog: minerador travado, reiniciando" >> "$MINER_LOGS/watchdog.log"
            pkill -f xmrig
            sleep 2
            "$SCRIPT_PATH" --restart-mining
        fi
    fi
    sleep 30
done
INNEREOF
    chmod +x "$MINER_SCRIPTS/watchdog.sh"
    nohup "$MINER_SCRIPTS/watchdog.sh" >/dev/null 2>&1 &
    echo $! > "$MINER_STATS/watchdog.pid"
    log_ok "Watchdog iniciado"
}

stop_watchdog() {
    [ -f "$MINER_STATS/watchdog.pid" ] && kill $(cat "$MINER_STATS/watchdog.pid") 2>/dev/null
    pkill -f watchdog.sh 2>/dev/null
}

# ----------------------------------------------------------------------------
# INICIAR MINERA√á√ÉO
# ----------------------------------------------------------------------------
start_mining() {
    if pgrep -f xmrig >/dev/null; then
        log_warn "Minera√ß√£o j√° est√° ativa"
        return 1
    fi
    install_xmrig_mega || { log_error "Falha na instala√ß√£o do XMRig"; exit 1; }
    if [ ! -f "$MINER_CONFIG/config.json" ]; then
        configure_miner
    fi
    enable_wake_lock
    echo "$(get_shares)" > "$MINER_STATS/last_shares"
    cd "$MINER_ROOT"
    nohup "$MINER_BIN/xmrig" -c "$MINER_CONFIG/config.json" >> "$MINER_LOGS/miner.log" 2>&1 &
    local pid=$!
    echo $pid > "$MINER_STATS/miner.pid"
    sleep 3
    if kill -0 $pid 2>/dev/null; then
        local worker=$(grep "^WORKER=" "$MINER_CONFIG/worker.info" 2>/dev/null | cut -d= -f2)
        local pool=$(grep "^POOL=" "$MINER_CONFIG/worker.info" 2>/dev/null | cut -d= -f2)
        log_ok "Minera√ß√£o iniciada (PID: $pid) | Pool: $pool"
        notify_all "üöÄ Minera√ß√£o iniciada\nWorker: $worker\nPool: $pool" "3066993" "In√≠cio"
        # Loop de estat√≠sticas em background
        (
            while kill -0 $pid 2>/dev/null; do
                update_stats
                log_satoshi_auto
                sleep 60
            done
        ) &
        echo $! > "$MINER_STATS/stats_loop.pid"
        return 0
    else
        log_error "Falha ao iniciar minera√ß√£o"
        notify_all "‚ùå Falha ao iniciar minera√ß√£o" "15158332" "ERRO"
        return 1
    fi
}

restart_mining() {
    pkill -f xmrig
    sleep 2
    start_mining
}

# ----------------------------------------------------------------------------
# MONITORAMENTO PRINCIPAL (DASHBOARD)
# ----------------------------------------------------------------------------
monitor_loop() {
    log_info "Monitoramento iniciado. Pressione Ctrl+C para parar."
    while true; do
        clear
        echo -e "${PURPLE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
        echo -e "${PURPLE}         XMRIG MINER GOD ‚Äì MEGA ULTRA FINAL v$SYSTEM_VERSION${NC}"
        echo -e "${PURPLE}                    $(date '+%d/%m/%Y %H:%M:%S')${NC}"
        echo -e "${PURPLE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}\n"
        
        if pgrep -f xmrig >/dev/null; then
            hashrate=$(get_hashrate)
            temp=$(get_temp)
            sats=$(get_total_satoshis)
            shares=$(get_total_shares)
            pool=$(grep "^POOL=" "$MINER_CONFIG/worker.info" 2>/dev/null | cut -d= -f2)
            pool_short=$(echo "$pool" | cut -d. -f1-2)
            uptime_sec=$(get_uptime_seconds)
            uptime_str="$((uptime_sec/3600))h $(((uptime_sec%3600)/60))m $((uptime_sec%60))s"
            hashrate_val=$(get_hashrate_value)
            usd_hour=$(echo "scale=6; $hashrate_val * 0.00000001 * 45000 * 3600" | bc 2>/dev/null || echo "0")
            usd_day=$(echo "scale=6; $usd_hour * 24" | bc 2>/dev/null || echo "0")
            
            echo -e "${GREEN}‚ñ∂ Minera√ß√£o: ATIVA${NC}"
            echo "   PID: $(pgrep -f xmrig)"
            echo "   Uptime: $uptime_str"
            echo ""
            echo -e "${CYAN}‚ö° Estat√≠sticas:${NC}"
            echo "   Hashrate: $hashrate"
            echo "   Temperatura: $temp¬∞C"
            echo "   Satoshis acumulados: $sats sats"
            echo "   Shares: $shares"
            echo "   USD/hora: \$$usd_hour"
            echo "   USD/dia: \$$usd_day"
            echo ""
            echo -e "${CYAN}üåê Pool:${NC} ${pool_short:-N/A}"
            echo -e "${CYAN}üëõ Carteira:${NC} ${WALLET_ADDRESS:0:20}..."
            echo -e "${CYAN}üîí TLS:${NC} $([ "$TLS_ENABLED" = true ] && echo "Ativado" || echo "Desativado")"
        else
            echo -e "${RED}‚ñ∂ Minera√ß√£o: INATIVA${NC}"
            echo ""
            echo -e "${YELLOW}Tentando reiniciar...${NC}"
            start_mining
        fi
        echo ""
        echo -e "${YELLOW}Monitoramento autom√°tico - Ctrl+C para encerrar${NC}"
        sleep 60
    done
}

# ----------------------------------------------------------------------------
# TRATAMENTO DE ARGUMENTOS
# ----------------------------------------------------------------------------
if [ "$1" = "--switch-pool" ] && [ -n "$2" ]; then
    switch_pool "$2" "$3"
    exit 0
fi

if [ "$1" = "--restart-mining" ]; then
    restart_mining
    exit 0
fi

if [ "$1" = "--source-only" ]; then
    return 0
fi

# ----------------------------------------------------------------------------
# TRAP DE SA√çDA
# ----------------------------------------------------------------------------
clean_exit() {
    echo -e "\n${YELLOW}Encerrando minera√ß√£o...${NC}"
    stop_auto_pool_daemon
    stop_watchdog
    pkill -f xmrig
    [ -f "$MINER_STATS/stats_loop.pid" ] && kill $(cat "$MINER_STATS/stats_loop.pid") 2>/dev/null
    disable_wake_lock
    local sats=$(get_total_satoshis)
    notify_all "üõë Minera√ß√£o encerrada\nTotal de satoshis: $sats" "15158332" "Parada"
    exit 0
}
trap clean_exit SIGINT SIGTERM

# ----------------------------------------------------------------------------
# EXECU√á√ÉO PRINCIPAL
# ----------------------------------------------------------------------------
clear
echo -e "${PURPLE}‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó"
echo "‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù"
echo "‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó"
echo "‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë"
echo "‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë"
echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
echo -e "${PURPLE}üî• XMRIG MINER GOD ‚Äì MEGA ULTRA FINAL v$SYSTEM_VERSION üî•${NC}\n"

# Verifica se est√° no Termux
if [ ! -d "/data/data/com.termux" ]; then
    echo -e "${RED}Este script deve ser executado no Termux!${NC}"
    exit 1
fi

# Configura diret√≥rio tempor√°rio seguro
setup_temp

# Inicializa arquivos de estat√≠stica
[ ! -f "$MINER_STATS/total_satoshis" ] && echo "0" > "$MINER_STATS/total_satoshis"
[ ! -f "$MINER_STATS/total_shares" ] && echo "0" > "$MINER_STATS/total_shares"
[ ! -f "$MINER_STATS/current_hashrate" ] && echo "0" > "$MINER_STATS/current_hashrate"
[ ! -f "$MINER_STATS/current_temp" ] && echo "0" > "$MINER_STATS/current_temp"
[ ! -f "$MINER_STATS/last_shares" ] && echo "0" > "$MINER_STATS/last_shares"

# Instala depend√™ncias b√°sicas
install_deps
fix_repos

# Inicia a minera√ß√£o
start_mining

# Inicia servi√ßos adicionais
[ "$AUTO_POOL" = true ] && start_auto_pool_daemon
[ "$WATCHDOG" = true ] && start_watchdog

# Entra no loop de monitoramento
monitor_loop
