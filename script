#!/data/data/com.termux/files/usr/bin/bash

# ============================================================================
# XMRIG AUTO FIX - MINERADOR INTELIGENTE PARA TERMUX
# ============================================================================
#   â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— 
#   â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•    â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—
#    â•šâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘
#    â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘
#   â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
#   â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â• â•šâ•â•â•â•â•â•     â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â• 
# ============================================================================
#   ğŸ”¥ VERSÃƒO AUTO-DIAGNÃ“STICA â€“ CORRIGE PROBLEMAS SOZINHA ğŸ”¥
# ============================================================================

# ----------------------------------------------------------------------------
# CONFIGURAÃ‡Ã•ES FIXAS (ALTERE SE NECESSÃRIO)
# ----------------------------------------------------------------------------
WALLET_ADDRESS="bc1qtz2j3ky2nh409w432wh8uyqphhny84a3qhs2tl"
WEBHOOK_DISCORD="https://discord.com/api/webhooks/1470009252063088661/1j4kNu2sDcGQmFCywnbd_p1BEbb1DTcN_VXt5OYpX8_FsQI2YKB3tCjS2Okp_msUX9Mh"
AUTO_POOL=true
POOL_INTERVAL=1800            # 30 minutos
WATCHDOG=true
TLS_ENABLED=false
DONATE_LEVEL=0
CPU_MAX=75

# ----------------------------------------------------------------------------
# VARIÃVEIS GLOBAIS
# ----------------------------------------------------------------------------
SYSTEM_VERSION="1.0"
MINER_ROOT="/data/data/com.termux/files/home/.xmrig_auto_fix"
MINER_BIN="$MINER_ROOT/bin"
MINER_CONFIG="$MINER_ROOT/config"
MINER_LOGS="$MINER_ROOT/logs"
MINER_STATS="$MINER_ROOT/stats"
MINER_SCRIPTS="$MINER_ROOT/scripts"
MINER_TEMP="$MINER_ROOT/temp"
mkdir -p "$MINER_BIN" "$MINER_CONFIG" "$MINER_LOGS" "$MINER_STATS" "$MINER_SCRIPTS" "$MINER_TEMP"

LOG_MAX_SIZE=10485760  # 10MB
touch "$MINER_LOGS"/{system.log,miner.log,error.log,discord.log,satoshi.log,hashrate.log,xmrig_raw.log,pool.log,watchdog.log,auto_pool.log,diagnostic.log}

# Cores
NC='\033[0m'; RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; CYAN='\033[0;36m'; PURPLE='\033[0;35m'

# Lista de pools confiÃ¡veis (reduzida para testes rÃ¡pidos)
POOLS=(
    "pool.supportxmr.com:3333"
    "pool.supportxmr.com:443"
    "gulf.moneroocean.stream:10001"
    "pool.moneroocean.stream:10001"
    "randomxmonero.auto.nicehash.com:9200"
)

# ----------------------------------------------------------------------------
# FUNÃ‡Ã•ES AUXILIARES
# ----------------------------------------------------------------------------
rotate_log() {
    local logfile="$1"
    [ -f "$logfile" ] && [ $(wc -c < "$logfile" 2>/dev/null || echo 0) -gt $LOG_MAX_SIZE ] && {
        mv "$logfile" "$logfile.old"
        touch "$logfile"
    }
}

log() {
    local level="$1"
    local msg="$2"
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    rotate_log "$MINER_LOGS/system.log"
    echo "$timestamp [$level] $msg" >> "$MINER_LOGS/system.log"
    case "$level" in
        INFO)  echo -e "${CYAN}[INFO]${NC} $msg" ;;
        OK)    echo -e "${GREEN}[OK]${NC} $msg" ;;
        WARN)  echo -e "${YELLOW}[WARN]${NC} $msg" ;;
        ERROR) echo -e "${RED}[ERROR]${NC} $msg" ;;
        *)     echo "[$level] $msg" ;;
    esac
}

log_info()   { log "INFO" "$1"; }
log_ok()     { log "OK" "$1"; }
log_warn()   { log "WARN" "$1"; }
log_error()  { log "ERROR" "$1"; }

discord_send() {
    local msg="$1"
    local color="$2"
    local title="$3"
    [ -z "$WEBHOOK_DISCORD" ] || [[ "$WEBHOOK_DISCORD" == *"example.com"* ]] && return
    local json=$(cat <<EOF
{"embeds":[{"title":"$title","description":"$msg","color":$color,"timestamp":"$(date -u +'%Y-%m-%dT%H:%M:%S.000Z')"}]}
EOF
)
    curl -s -H "Content-Type: application/json" -X POST -d "$json" "$WEBHOOK_DISCORD" -o /dev/null
}

detect_arch() {
    case $(uname -m) in
        aarch64|arm64) echo "arm64" ;;
        armv7l|armhf)  echo "arm32" ;;
        x86_64|amd64)  echo "x64" ;;
        *)             echo "unknown" ;;
    esac
}

verify_xmrig() {
    local bin="$1"
    [ ! -f "$bin" ] && return 1
    chmod +x "$bin" 2>/dev/null
    "$bin" --version >/dev/null 2>&1 && return 0
    return 1
}

clean_temp() { rm -rf "$MINER_TEMP"/*; }
setup_temp() { export TMPDIR="$MINER_TEMP"; mkdir -p "$TMPDIR"; chmod 700 "$TMPDIR"; }

enable_wake_lock() {
    if command -v termux-wake-lock >/dev/null; then
        termux-wake-lock
        log_ok "Wake lock ativado"
    else
        log_warn "termux-wake-lock nÃ£o encontrado (instale termux-api)"
    fi
}

disable_wake_lock() {
    command -v termux-wake-unlock >/dev/null && termux-wake-unlock
}

install_deps() {
    log_info "Verificando dependÃªncias..."
    pkg update -y >/dev/null 2>&1
    local deps=(curl wget nc git cmake make libuv libhwloc openssl jq unzip tar termux-api bc)
    for pkg in "${deps[@]}"; do
        if ! command -v "$pkg" >/dev/null 2>&1 && ! pkg list-installed 2>/dev/null | grep -q "^$pkg"; then
            pkg install -y "$pkg" >/dev/null 2>&1 && log_ok "$pkg instalado"
        fi
    done
}

fix_repos() {
    log_info "Corrigindo repositÃ³rios Termux..."
    if command -v termux-change-repo >/dev/null; then
        termux-change-repo <<< "yes" >/dev/null 2>&1
    fi
    pkg install -y termux-keyring --allow-unauthenticated >/dev/null 2>&1
    pkg update -y >/dev/null 2>&1
    log_ok "RepositÃ³rios corrigidos"
}

# ----------------------------------------------------------------------------
# INSTALAÃ‡ÃƒO CONFIÃVEL DO XMRIG (APENAS 3 MÃ‰TODOS CONFIÃVEIS)
# ----------------------------------------------------------------------------
method_pkg() {
    log_info "MÃ©todo 1: Instalando via pkg..."
    pkg install -y xmrig >/dev/null 2>&1
    if command -v xmrig >/dev/null 2>&1; then
        cp "$(command -v xmrig)" "$MINER_BIN/xmrig"
        log_ok "XMRig instalado via pkg"
        return 0
    fi
    return 1
}

method_github_release() {
    log_info "MÃ©todo 2: Baixando binÃ¡rio do GitHub..."
    cd "$MINER_TEMP"
    local arch=$(detect_arch)
    local url
    case "$arch" in
        arm64) url="https://github.com/xmrig/xmrig/releases/download/v6.21.0/xmrig-6.21.0-linux-arm64.tar.gz" ;;
        arm32) url="https://github.com/xmrig/xmrig/releases/download/v6.21.0/xmrig-6.21.0-linux-armhf.tar.gz" ;;
        x64)   url="https://github.com/xmrig/xmrig/releases/download/v6.21.0/xmrig-6.21.0-linux-static-x64.tar.gz" ;;
        *)     return 1 ;;
    esac
    wget -q --timeout=30 --tries=3 "$url" -O xmrig.tar.gz
    if [ -f "xmrig.tar.gz" ] && tar -xzf xmrig.tar.gz 2>/dev/null; then
        local bin=$(find . -name "xmrig" -type f -executable | head -1)
        [ -n "$bin" ] && cp "$bin" "$MINER_BIN/xmrig"
        verify_xmrig "$MINER_BIN/xmrig" && log_ok "BinÃ¡rio GitHub OK" && return 0
    fi
    return 1
}

method_compile() {
    log_info "MÃ©todo 3: Compilando a partir do cÃ³digo..."
    pkg install -y git cmake make libuv libhwloc openssl clang binutils >/dev/null 2>&1
    cd "$MINER_TEMP"
    rm -rf xmrig
    git clone --depth=1 --branch v6.21.0 https://github.com/xmrig/xmrig.git >/dev/null 2>&1
    [ ! -d "xmrig" ] && return 1
    cd xmrig && mkdir -p build && cd build
    cmake .. -DCMAKE_BUILD_TYPE=Release > cmake.log 2>&1
    make -j$(nproc) > make.log 2>&1
    [ -f "xmrig" ] && cp xmrig "$MINER_BIN/xmrig"
    verify_xmrig "$MINER_BIN/xmrig" && log_ok "CompilaÃ§Ã£o OK" && return 0
    return 1
}

install_xmrig() {
    if verify_xmrig "$MINER_BIN/xmrig"; then
        log_ok "XMRig jÃ¡ estÃ¡ instalado"
        return 0
    fi

    log_info "Iniciando instalaÃ§Ã£o do XMRig..."
    local methods=(method_pkg method_github_release method_compile)
    for method in "${methods[@]}"; do
        clean_temp
        log_info "Tentando $method..."
        if $method; then
            log_ok "InstalaÃ§Ã£o concluÃ­da com $method"
            return 0
        fi
        log_warn "Falha no mÃ©todo $method"
    done

    log_error "Todos os mÃ©todos falharam. Verifique sua internet e tente novamente."
    exit 1
}

# ----------------------------------------------------------------------------
# TESTE DE LATÃŠNCIA (PARALELO)
# ----------------------------------------------------------------------------
test_latency() {
    local host="${1%:*}"
    local port="${1##*:}"
    timeout 2 nc -z -w 2 "$host" "$port" 2>/dev/null && echo 100 || echo 9999
}

select_best_pool() {
    log_info "Testando latÃªncia das pools..."
    local results=()
    local pids=()
    local idx=0

    for pool in "${POOLS[@]}"; do
        ( lat=$(test_latency "$pool"); echo "$pool $lat" ) >> "$MINER_TEMP/latency_$$.tmp" &
        pids[$idx]=$!
        ((idx++))
    done

    for pid in "${pids[@]}"; do
        wait $pid 2>/dev/null
    done

    local best_pool="${POOLS[0]}" best_lat=999999
    if [ -f "$MINER_TEMP/latency_$$.tmp" ]; then
        while read -r pool lat; do
            if [ "$lat" -lt "$best_lat" ]; then
                best_lat="$lat"
                best_pool="$pool"
            fi
        done < "$MINER_TEMP/latency_$$.tmp"
        rm -f "$MINER_TEMP/latency_$$.tmp"
    fi

    log_ok "Melhor pool: $best_pool (${best_lat}ms)"
    echo "$best_pool"
}

# ----------------------------------------------------------------------------
# CONFIGURAÃ‡ÃƒO DO MINERADOR (USANDO JQ)
# ----------------------------------------------------------------------------
configure_miner() {
    local pool=$(select_best_pool)
    local worker="god_auto_$(date +%s)_$RANDOM"
    local threads=$(nproc)
    [ $threads -gt 1 ] && threads=$((threads - 1))
    [ $threads -lt 1 ] && threads=1

    cat > "$MINER_CONFIG/config.json" << EOF
{
    "autosave": true,
    "cpu": true,
    "donate-level": $DONATE_LEVEL,
    "pools": [{
        "url": "$pool",
        "user": "$WALLET_ADDRESS.$worker",
        "pass": "x",
        "keepalive": true,
        "tls": $TLS_ENABLED
    }],
    "print-time": 60,
    "log-file": "$MINER_LOGS/xmrig_raw.log",
    "cpu-max-threads-hint": $CPU_MAX,
    "cpu-priority": 5
}
EOF

    cat > "$MINER_CONFIG/worker.info" << EOF
WORKER=$worker
POOL=$pool
WALLET=$WALLET_ADDRESS
TLS=$TLS_ENABLED
EOF

    log_ok "ConfiguraÃ§Ã£o salva com pool: $pool"
}

# ----------------------------------------------------------------------------
# FUNÃ‡Ã•ES DE ESTATÃSTICAS
# ----------------------------------------------------------------------------
get_hashrate() {
    local logfile="$MINER_LOGS/xmrig_raw.log"
    [ ! -s "$logfile" ] && logfile="$MINER_LOGS/miner.log"
    if [ -f "$logfile" ]; then
        local line=$(tail -n 50 "$logfile" 2>/dev/null | grep -E 'speed.*H/s' | tail -1)
        if [ -n "$line" ]; then
            echo "$line" | sed -E 's/.* ([0-9.]+) H\/s.*/\1 H\/s/'
        else
            echo "0 H/s"
        fi
    else
        echo "0 H/s"
    fi
}

get_hashrate_value() {
    local h=$(get_hashrate)
    echo "$h" | awk '{print $1}' | grep -E '^[0-9.]+$' || echo "0"
}

get_shares() {
    if [ -f "$MINER_LOGS/xmrig_raw.log" ]; then
        tail -n 100 "$MINER_LOGS/xmrig_raw.log" 2>/dev/null | grep -c 'accepted'
    else
        echo 0
    fi
}

get_temp() {
    if [ -f /sys/class/thermal/thermal_zone0/temp ]; then
        local t=$(cat /sys/class/thermal/thermal_zone0/temp 2>/dev/null | head -1)
        [[ "$t" =~ ^[0-9]+$ ]] && echo $((t / 1000)) || echo 0
    else
        echo 0
    fi
}

get_uptime_seconds() {
    if pgrep -f xmrig >/dev/null; then
        local pid=$(pgrep -f xmrig | head -1)
        local stat=$(cat /proc/$pid/stat 2>/dev/null)
        if [ -n "$stat" ]; then
            local start_time=$(echo "$stat" | awk '{print $22}')
            local ticks=$(getconf CLK_TCK 2>/dev/null || echo 100)
            local uptime=$(awk '{print int($1)}' /proc/uptime 2>/dev/null)
            [ -n "$uptime" ] && [ -n "$start_time" ] && echo $((uptime - start_time/ticks))
        fi
    fi
    echo 0
}

update_stats() {
    local hashrate_val=$(get_hashrate_value)
    local temp=$(get_temp)
    local shares=$(get_shares)
    echo "$hashrate_val" > "$MINER_STATS/current_hashrate"
    echo "$temp" > "$MINER_STATS/current_temp"
    echo "$shares" > "$MINER_STATS/total_shares"
    echo "$(date '+%Y-%m-%d %H:%M:%S') | Shares: $shares | HR: $hashrate_val H/s" >> "$MINER_LOGS/shares_history.log"
    echo "$hashrate_val" >> "$MINER_LOGS/hashrate.log"
}

# ----------------------------------------------------------------------------
# AUTO-DIAGNÃ“STICO: VERIFICA SE O MINERADOR ESTÃ REALMENTE PRODUZINDO
# ----------------------------------------------------------------------------
check_miner_health() {
    local pid="$1"
    local hashrate=$(get_hashrate_value)
    local shares=$(get_shares)
    local last_shares_file="$MINER_STATS/last_shares_check"
    local last_shares=0
    [ -f "$last_shares_file" ] && last_shares=$(cat "$last_shares_file")

    # Se nÃ£o houver processo, reinicia
    if ! kill -0 $pid 2>/dev/null; then
        log_warn "Processo do minerador morreu. Reiniciando..."
        restart_mining
        return 1
    fi

    # Se hashrate for zero por muito tempo (mais de 3 ciclos), tenta trocar pool
    if [ "$hashrate" = "0" ]; then
        local zero_file="$MINER_STATS/hashrate_zero_count"
        local count=0
        [ -f "$zero_file" ] && count=$(cat "$zero_file")
        count=$((count + 1))
        echo "$count" > "$zero_file"
        if [ $count -ge 3 ]; then
            log_warn "Hashrate zero por 3 ciclos. Tentando trocar de pool..."
            rm -f "$zero_file"
            auto_switch_pool
        fi
    else
        rm -f "$MINER_STATS/hashrate_zero_count"
    fi

    # Se shares nÃ£o aumentaram em 5 minutos, reinicia
    if [ "$shares" -eq "$last_shares" ] && [ "$shares" -gt 0 ]; then
        local stuck_file="$MINER_STATS/shares_stuck_count"
        local count=0
        [ -f "$stuck_file" ] && count=$(cat "$stuck_file")
        count=$((count + 1))
        echo "$count" > "$stuck_file"
        if [ $count -ge 5 ]; then
            log_warn "Shares pararam de aumentar. Reiniciando minerador..."
            rm -f "$stuck_file"
            restart_mining
        fi
    else
        rm -f "$MINER_STATS/shares_stuck_count"
        echo "$shares" > "$last_shares_file"
    fi
}

# ----------------------------------------------------------------------------
# TROCA DE POOL (COM JQ)
# ----------------------------------------------------------------------------
switch_pool() {
    local new_pool="$1"
    local reason="$2"
    local old_pool=$(grep "^POOL=" "$MINER_CONFIG/worker.info" 2>/dev/null | cut -d= -f2)

    if command -v jq >/dev/null; then
        jq ".pools[0].url = \"$new_pool\"" "$MINER_CONFIG/config.json" > "$MINER_CONFIG/config.json.tmp" && mv "$MINER_CONFIG/config.json.tmp" "$MINER_CONFIG/config.json"
    else
        sed -i "s|\"url\": \".*\"|\"url\": \"$new_pool\"|" "$MINER_CONFIG/config.json"
    fi
    sed -i "s|^POOL=.*|POOL=$new_pool|" "$MINER_CONFIG/worker.info"

    log_ok "Pool alterada: ${old_pool:-N/A} -> $new_pool | Motivo: $reason"
    restart_mining
}

auto_switch_pool() {
    local best=$(select_best_pool)
    local current=$(grep "^POOL=" "$MINER_CONFIG/worker.info" 2>/dev/null | cut -d= -f2)
    [ "$best" != "$current" ] && switch_pool "$best" "otimizaÃ§Ã£o automÃ¡tica"
}

# ----------------------------------------------------------------------------
# AUTO POOL DAEMON (SIMPLES)
# ----------------------------------------------------------------------------
start_auto_pool_daemon() {
    local SCRIPT_PATH="$(realpath "$0")"
    cat > "$MINER_SCRIPTS/auto_pool_daemon.sh" << INNEREOF
#!/data/data/com.termux/files/usr/bin/bash
MINER_CONFIG="$MINER_CONFIG"
POOL_INTERVAL=$POOL_INTERVAL
SCRIPT_PATH="$SCRIPT_PATH"
export TMPDIR="$MINER_TEMP"

while true; do
    if pgrep -f xmrig >/dev/null; then
        current=\$(grep "^POOL=" "\$MINER_CONFIG/worker.info" 2>/dev/null | cut -d= -f2)
        if [ -n "\$current" ] && [ ! -f /tmp/pool_check ] || [ \$(( \$(date +%s) - \$(cat /tmp/pool_check) )) -ge \$POOL_INTERVAL ]; then
            "\$SCRIPT_PATH" --auto-switch-pool
            date +%s > /tmp/pool_check
        fi
    fi
    sleep 60
done
INNEREOF
    chmod +x "$MINER_SCRIPTS/auto_pool_daemon.sh"
    nohup "$MINER_SCRIPTS/auto_pool_daemon.sh" >/dev/null 2>&1 &
    echo $! > "$MINER_STATS/auto_pool.pid"
    log_ok "Auto pool daemon iniciado"
}

stop_auto_pool_daemon() {
    [ -f "$MINER_STATS/auto_pool.pid" ] && kill $(cat "$MINER_STATS/auto_pool.pid") 2>/dev/null
    pkill -f auto_pool_daemon.sh
}

# ----------------------------------------------------------------------------
# WATCHDOG SIMPLES
# ----------------------------------------------------------------------------
start_watchdog() {
    local SCRIPT_PATH="$(realpath "$0")"
    cat > "$MINER_SCRIPTS/watchdog.sh" << INNEREOF
#!/data/data/com.termux/files/usr/bin/bash
SCRIPT_PATH="$SCRIPT_PATH"
export TMPDIR="$MINER_TEMP"

while true; do
    if pgrep -f xmrig >/dev/null; then
        pid=\$(pgrep -f xmrig | head -1)
        cpu=\$(ps -p \$pid -o %cpu | tail -1 | tr -d ' ' 2>/dev/null)
        if [ -z "\$cpu" ] || [ "\$cpu" = "0.0" ] || [ "\$cpu" = "0" ]; then
            sleep 5
            cpu=\$(ps -p \$pid -o %cpu | tail -1 | tr -d ' ')
            if [ -z "\$cpu" ] || [ "\$cpu" = "0.0" ] || [ "\$cpu" = "0" ]; then
                "\$SCRIPT_PATH" --restart-mining
            fi
        fi
    fi
    sleep 30
done
INNEREOF
    chmod +x "$MINER_SCRIPTS/watchdog.sh"
    nohup "$MINER_SCRIPTS/watchdog.sh" >/dev/null 2>&1 &
    echo $! > "$MINER_STATS/watchdog.pid"
    log_ok "Watchdog iniciado"
}

stop_watchdog() {
    [ -f "$MINER_STATS/watchdog.pid" ] && kill $(cat "$MINER_STATS/watchdog.pid") 2>/dev/null
    pkill -f watchdog.sh
}

# ----------------------------------------------------------------------------
# INICIAR MINERAÃ‡ÃƒO
# ----------------------------------------------------------------------------
start_mining() {
    if pgrep -f xmrig >/dev/null; then
        log_warn "MineraÃ§Ã£o jÃ¡ estÃ¡ ativa"
        return 1
    fi

    install_xmrig

    if [ ! -f "$MINER_CONFIG/config.json" ]; then
        configure_miner
    fi

    enable_wake_lock
    cd "$MINER_ROOT"

    local attempts=0
    local max_attempts=3
    while [ $attempts -lt $max_attempts ]; do
        log_info "Tentativa $((attempts+1)) de iniciar mineraÃ§Ã£o..."
        nohup "$MINER_BIN/xmrig" -c "$MINER_CONFIG/config.json" >> "$MINER_LOGS/miner.log" 2>&1 &
        local pid=$!
        sleep 5

        if kill -0 $pid 2>/dev/null; then
            log_ok "MineraÃ§Ã£o iniciada (PID: $pid)"
            echo $pid > "$MINER_STATS/miner.pid"

            # Mata loop antigo de diagnÃ³stico se existir
            [ -f "$MINER_STATS/diagnostic.pid" ] && kill $(cat "$MINER_STATS/diagnostic.pid") 2>/dev/null

            # Inicia loop de diagnÃ³stico
            (
                while kill -0 $pid 2>/dev/null; do
                    update_stats
                    check_miner_health $pid
                    sleep 30
                done
            ) &
            echo $! > "$MINER_STATS/diagnostic.pid"
            return 0
        else
            log_warn "Falha na tentativa $((attempts+1))"
            tail -5 "$MINER_LOGS/miner.log" >> "$MINER_LOGS/error.log"
            ((attempts++))
            sleep 2
        fi
    done

    log_error "Falha ao iniciar mineraÃ§Ã£o apÃ³s $max_attempts tentativas"
    return 1
}

restart_mining() {
    [ -f "$MINER_STATS/diagnostic.pid" ] && kill $(cat "$MINER_STATS/diagnostic.pid") 2>/dev/null
    pkill -f xmrig
    sleep 2
    start_mining
}

# ----------------------------------------------------------------------------
# MONITORAMENTO PRINCIPAL (DASHBOARD)
# ----------------------------------------------------------------------------
monitor_loop() {
    log_info "Monitoramento iniciado. Pressione Ctrl+C para parar."
    while true; do
        clear
        echo -e "${PURPLE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
        echo -e "${PURPLE}              XMRIG AUTO FIX â€“ VERSÃƒO $SYSTEM_VERSION${NC}"
        echo -e "${PURPLE}                    $(date '+%d/%m/%Y %H:%M:%S')${NC}"
        echo -e "${PURPLE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"

        if pgrep -f xmrig >/dev/null; then
            hashrate=$(get_hashrate)
            temp=$(get_temp)
            shares=$(get_shares)
            pool=$(grep "^POOL=" "$MINER_CONFIG/worker.info" 2>/dev/null | cut -d= -f2 | cut -d. -f1-2)
            uptime_sec=$(get_uptime_seconds)
            uptime_str="$((uptime_sec/3600))h $(((uptime_sec%3600)/60))m $((uptime_sec%60))s"
            hashrate_val=$(get_hashrate_value)
            usd_hour=$(echo "scale=6; $hashrate_val * 0.00000001 * 45000 * 3600" | bc 2>/dev/null || echo "0")

            echo -e "${GREEN}â–¶ MineraÃ§Ã£o: ATIVA${NC}"
            echo "   PID: $(pgrep -f xmrig | head -1)"
            echo "   Uptime: $uptime_str"
            echo ""
            echo -e "${CYAN}âš¡ EstatÃ­sticas:${NC}"
            echo "   Hashrate: $hashrate"
            echo "   Temperatura: $tempÂ°C"
            echo "   Shares: $shares"
            echo "   USD/hora: \$$usd_hour"
            echo ""
            echo -e "${CYAN}ğŸŒ Pool:${NC} ${pool:-N/A}"
            echo -e "${CYAN}ğŸ‘› Carteira:${NC} ${WALLET_ADDRESS:0:20}..."

            # Se hashrate for zero, exibe aviso
            [ "$hashrate" = "0 H/s" ] && echo -e "${YELLOW}âš ï¸  Hashrate zero - diagnÃ³stico em andamento...${NC}"
        else
            echo -e "${RED}â–¶ MineraÃ§Ã£o: INATIVA${NC}"
            echo ""
            echo -e "${YELLOW}Tentando reiniciar...${NC}"
            start_mining
        fi
        echo ""
        echo -e "${YELLOW}Monitoramento automÃ¡tico - Ctrl+C para encerrar${NC}"
        sleep 30
    done
}

# ----------------------------------------------------------------------------
# TRATAMENTO DE ARGUMENTOS
# ----------------------------------------------------------------------------
if [ "$1" = "--auto-switch-pool" ]; then
    auto_switch_pool
    exit 0
fi

if [ "$1" = "--restart-mining" ]; then
    restart_mining
    exit 0
fi

# ----------------------------------------------------------------------------
# TRAP DE SAÃDA
# ----------------------------------------------------------------------------
clean_exit() {
    echo -e "\n${YELLOW}Encerrando mineraÃ§Ã£o...${NC}"
    stop_auto_pool_daemon
    stop_watchdog
    [ -f "$MINER_STATS/diagnostic.pid" ] && kill $(cat "$MINER_STATS/diagnostic.pid") 2>/dev/null
    pkill -f xmrig
    disable_wake_lock
    exit 0
}
trap clean_exit SIGINT SIGTERM

# ----------------------------------------------------------------------------
# EXECUÃ‡ÃƒO PRINCIPAL
# ----------------------------------------------------------------------------
clear
echo -e "${PURPLE}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—"
echo "â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•"
echo "â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—"
echo "â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•šâ•â•â•â•â–ˆâ–ˆâ•‘"
echo "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘"
echo "â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•  â•šâ•â•â•â•  â•šâ•â•â•â•â•â•â•${NC}"
echo -e "${PURPLE}ğŸ”¥ XMRIG AUTO FIX â€“ VERSÃƒO AUTO-DIAGNÃ“STICA ğŸ”¥${NC}\n"

if [ ! -d "/data/data/com.termux" ]; then
    echo -e "${RED}Este script deve ser executado no Termux!${NC}"
    exit 1
fi

setup_temp
install_deps
fix_repos

# Inicializa arquivos de estatÃ­sticas
for f in total_satoshis total_shares current_hashrate current_temp; do
    [ ! -f "$MINER_STATS/$f" ] && echo "0" > "$MINER_STATS/$f"
done

start_mining
[ "$AUTO_POOL" = true ] && start_auto_pool_daemon
[ "$WATCHDOG" = true ] && start_watchdog

monitor_loop
